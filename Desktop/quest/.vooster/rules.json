{
  "rules": [
    {
      "type": "prd",
      "content": "# Product Requirements Document  \nIntelligent Test Management System (ITMS) – Desktop App  \n\n## 1. Executive Summary  \nITMS is an all-in-one desktop solution that streamlines test planning, execution, result tracking, and defect management. By combining intuitive, “smooth interactive” UX with AI-driven insights, the product boosts QA productivity, elevates software quality, and improves cross-team collaboration.\n\n## 2. Problem Statement  \nCurrent QA workflows are fragmented across spreadsheets, standalone defect tools, and manual reports, causing:  \n- High effort to create, update, and locate test assets  \n- Slow, error-prone result logging and defect reporting  \n- Limited real-time visibility for managers  \n- Low reuse of historical data for predictive analytics  \nA unified, intelligent platform is required to close these gaps.\n\n## 3. Goals and Objectives  \nPrimary Goal  \n• Provide a single, intelligent workspace for end-to-end test management.  \n\nSecondary Goals  \n• Accelerate test asset creation and maintenance  \n• Reduce repetitive manual work via automation suggestions  \n• Improve decision speed with real-time dashboards  \n• Enhance team communication through built-in collaboration  \n\nSuccess Metrics  \n• 40 % reduction in test preparation time (survey)  \n• 30 % faster defect turnaround (Jira timestamps)  \n• ≥90 % weekly active QA users after 3 months  \n• <2 sec average screen response under 5k concurrent cases  \n\n## 4. Target Audience  \nPrimary Users  \n• QA Engineers / Testers – daily creation, execution, logging  \n• QA Leads – planning, resource allocation, quality metrics  \n\nSecondary Users  \n• Developers – view/confirm defects, link code changes  \n• Project/Product Managers – release go/no-go decisions  \n• Business Analysts – verify requirement coverage  \n\n## 5. User Stories (sample)  \n- As a QA engineer, I want inline editing of test steps so that I update cases without page swaps.  \n- As a developer, I want failed test logs auto-attached to Jira issues so that I can reproduce bugs quickly.  \n- As a PM, I want a release dashboard showing pass rate and critical defects so that I judge shipment readiness.  \n- As a QA lead, I want AI to propose regression suites impacted by recent commits so that I focus on high-risk areas.  \n\n## 6. Functional Requirements  \n### 6.1 Core Features (MVP)  \n1. Test Case Management  \n   • CRUD with fields: title, prereq, steps, expected, priority, tags, status  \n   • Version history & rollback  \n   • Advanced search & multi-filter  \n   Acceptance: user edits case inline, change logged in history panel.  \n\n2. Release & Suite Planning  \n   • Define release/iteration objects  \n   • Drag-and-drop cases into suites  \n   • Assign executors, environments, due dates  \n   Acceptance: suite shows aggregated status per release.  \n\n3. Test Execution & Result Recording  \n   • State selection: Pass/Fail/Blocked/Untested  \n   • Failure detail: repro steps, screenshots, log files  \n   • Offline execution → auto sync on reconnect  \n   Acceptance: execution record visible in history within 5 sec.  \n\n4. Defect Management Integration  \n   • One-click defect creation inside ITMS or to Jira/Redmine via REST API  \n   • Bi-directional status sync  \n   Acceptance: Jira issue ID visible in test run row.  \n\n5. Dashboard & Basic Reporting  \n   • Real-time charts: progress %, defect density, tester workload  \n   • Widget customization via drag-and-drop  \n   Acceptance: dashboard updates within 3 sec after new result.  \n\n6. User & Role Management  \n   • Roles: Admin, QA, Dev, PM (RBAC)  \n   • SSO via SAML/OAuth2  \n   Acceptance: non-authorized user blocked from admin panel.  \n\n7. Basic Collaboration  \n   • Comment & @mention on cases, runs, defects  \n   • Notification center (in-app + email)  \n\n### 6.2 Intelligent & UX Enhancements (Phase 2+)  \n- AI case generation from requirement text or source diff (NLP + AST)  \n- Impact analysis recommending suites affected by latest commits  \n- Failure hotspot prediction per module/sprint  \n- Risk-based test prioritization report  \n- Animated charts & smooth transitions (60 fps)  \n- Real-time collaborative editing (OT/CRDT)  \n\n## 7. Non-Functional Requirements  \nPerformance: <2 sec avg UI response; bulk import 10k cases <60 sec  \nSecurity: AES-256 at rest, TLS 1.3 in transit, OWASP Top 10 compliance  \nUsability: onboarding ≤30 min; WCAG 2.1 AA accessible  \nScalability: handle 1 M cases, 500 concurrent active users  \nCompatibility: Windows 10/11 desktop app, optional WebView for Mac/Linux  \n\n## 8. Technical Considerations  \nArchitecture: Electron front-end + Node.js backend (desktop), microservice API layer (Go) for integrations.  \nDatabase: PostgreSQL for relational data; Elasticsearch for search.  \nAI Services: Python microservice with HuggingFace models, served via REST; TensorFlow Lite for on-device predictions.  \nIntegrations: Jira/Redmine (REST), GitLab/GitHub Webhooks, CI tools (Jenkins) via plugin SDK.  \nData Sync: gRPC channel for real-time events; local IndexedDB cache for offline mode.  \nDeployment: Auto-update via Electron auto-updater; MSI installer for enterprises.  \n\n## 9. Success Metrics & KPIs  \nUser Adoption: WAU/MAU, daily session length  \nQuality Impact: Defect leakage to production ↓25 %  \nProcess Efficiency: Avg cycle time from defect detection to closure ↓30 %  \nSystem Health: p95 API latency <300 ms; error rate <0.1 %  \n\n## 10. Timeline & Milestones  \nPhase 0 – Discovery (2 w): detailed spec, prototypes  \nPhase 1 – MVP (12 w): Core Features 1-7, basic Jira sync  \nPhase 2 – UX polish & CI/CD integration (8 w)  \nPhase 3 – AI features & real-time collaboration (12 w)  \nBeta Release: end of Phase 2; GA: end of Phase 3  \n\n## 11. Risks & Mitigation  \nTechnical: AI accuracy low → provide manual override & feedback loop  \nPerformance: Desktop app bloat → code-split, lazy load modules  \nAdoption: Users resist migration → CSV import tool, in-app tutorials  \nIntegrations: API changes in Jira → versioned adapter layer  \n\n## 12. Future Considerations  \n• Cloud SaaS edition for cross-platform access  \n• Low-code test automation recorder  \n• Marketplace for community plugins  \n• Advanced analytics dashboard with anomaly detection  \n• Expanded compliance modules (ISO 29119, FDA 21 CFR Part 11)",
      "writedAt": "2025-07-23T05:34:58.140Z"
    },
    {
      "type": "architecture",
      "content": "# 기술 요구사항 문서 (TRD)\n\n## 1. 기술 개요\n\n### 프로젝트 개요\nITMS(지능형 테스트 관리 시스템)는 테스트 계획, 실행, 결과 추적 및 결함 관리를 간소화하는 데스크톱 애플리케이션입니다. 사용자 친화적인 UX와 AI 기반 통찰력을 결합하여 QA 생산성을 높이고 소프트웨어 품질을 향상하며 팀 간 협업을 개선하는 것을 목표로 합니다. 본 문서는 PRD의 요구사항을 충족하기 위한 기술적 접근 방식과 아키텍처 결정을 제시하며, 과도한 엔지니어링을 피하고 실용적이고 효율적인 솔루션에 중점을 둡니다.\n\n### 핵심 기술 스택\n*   **프론트엔드**: Electron (UI: React, 상태 관리: Redux)\n*   **백엔드 (데스크톱)**: Node.js (Express.js)\n*   **데이터베이스**: PostgreSQL\n*   **검색 엔진**: Elasticsearch\n*   **AI 서비스**: Python (Flask/FastAPI, HuggingFace, TensorFlow Lite)\n*   **통신**: REST API, gRPC\n*   **배포**: Electron auto-updater, MSI Installer\n\n### 주요 기술 목표\n*   **성능**: 평균 UI 응답 시간 2초 미만, 5천 동시 케이스 처리 시 평균 화면 응답 시간 2초 미만.\n*   **확장성**: 1백만 개 케이스 및 500명 동시 활성 사용자 처리.\n*   **안정성**: 데이터 무결성 보장, 오프라인 모드 지원 및 재연결 시 자동 동기화.\n*   **보안**: AES-256 저장 암호화, TLS 1.3 전송 암호화, OWASP Top 10 준수.\n*   **유지보수성**: 명확한 코드 구조, 모듈화된 컴포넌트, 쉬운 디버깅.\n\n### 중요한 기술 가정\n*   데스크톱 애플리케이션은 사용자 로컬 환경에서 실행되며, 데이터는 로컬 PostgreSQL 인스턴스에 저장됩니다.\n*   AI 서비스는 별도의 마이크로서비스로 분리되어 필요에 따라 로컬 또는 원격으로 배포될 수 있습니다.\n*   외부 시스템(Jira, Redmine 등)과의 통합은 REST API를 통해 이루어집니다.\n*   사용자 인증 및 권한 관리는 애플리케이션 내에서 처리되며, SSO는 SAML/OAuth2를 통해 지원됩니다.\n*   오프라인 기능은 IndexedDB 캐싱을 통해 구현됩니다.\n\n## 2. 기술 스택\n\n| 카테고리 | 기술 / 라이브러리 | 선택 이유 (이 프로젝트에 선택된 이유) |\n| :------- | :---------------- | :----------------------------------- |\n| **데스크톱 애플리케이션 프레임워크** | Electron | 데스크톱 앱 개발을 위한 웹 기술(HTML, CSS, JavaScript) 활용, Windows, macOS, Linux 크로스 플랫폼 지원. |\n| **프론트엔드 UI 라이브러리** | React | 컴포넌트 기반의 선언적 UI 개발, 활발한 커뮤니티 지원, 풍부한 생태계. |\n| **프론트엔드 상태 관리** | Redux | 복잡한 애플리케이션의 예측 가능한 상태 관리, 디버깅 용이성, 미들웨어 확장성. |\n| **백엔드 (데스크톱 앱 내부)** | Node.js (Express.js) | JavaScript 기반으로 프론트엔드 개발자와의 기술 스택 통일, 경량화된 백엔드 API 서버 구축 용이. |\n| **데이터베이스** | PostgreSQL | 강력한 관계형 데이터베이스, ACID 준수, 확장성, 안정성, JSONB 지원으로 유연한 데이터 모델링 가능. |\n| **검색 엔진** | Elasticsearch | 고급 검색 및 필터링 기능, 대용량 데이터 처리, 실시간 인덱싱 및 분석 능력. |\n| **AI 서비스 (언어)** | Python (Flask/FastAPI) | AI/ML 라이브러리(HuggingFace, TensorFlow) 생태계가 가장 풍부, 경량 웹 프레임워크로 AI 모델 서빙에 적합. |\n| **AI/ML 라이브러리** | HuggingFace Transformers, TensorFlow Lite | NLP 모델(HuggingFace) 및 온디바이스 추론(TensorFlow Lite)을 위한 업계 표준 라이브러리. |\n| **데이터 동기화/실시간 통신** | gRPC | 고성능, 저지연 통신 프로토콜, 양방향 스트리밍 지원, 구조화된 데이터 교환에 효율적. |\n| **오프라인 데이터 캐싱** | IndexedDB | 브라우저(Electron WebView) 내 대용량 구조화된 데이터 저장, 오프라인 모드 지원. |\n| **API 통신** | REST API | 외부 시스템(Jira, Redmine 등)과의 표준화된 연동 방식, 범용성 및 상호 운용성. |\n| **인증/권한 관리** | Passport.js (Node.js) | 다양한 인증 전략(로컬, SAML, OAuth2) 지원, 유연한 확장성. |\n| **테스트 프레임워크** | Jest, React Testing Library, Supertest | 유닛/통합 테스트를 위한 표준 도구, 빠른 실행, 개발자 친화적. |\n| **패키지 관리** | npm/Yarn | Node.js 생태계의 표준 패키지 관리자, 의존성 관리 및 스크립트 실행. |\n\n## 3. 시스템 아키텍처 설계\n\n### 최상위 빌딩 블록\n*   **ITMS 데스크톱 애플리케이션**:\n    *   **프론트엔드 (Electron Renderer Process)**: React 기반의 사용자 인터페이스를 담당하며, 사용자 입력 처리 및 데이터 시각화를 수행합니다. Redux를 통해 애플리케이션 상태를 관리합니다.\n    *   **백엔드 (Electron Main Process / Node.js)**: 애플리케이션의 핵심 로직을 처리하고, 데이터베이스 및 외부 서비스와의 통신을 관리합니다. Express.js를 사용하여 내부 API를 제공합니다.\n    *   **로컬 데이터베이스 (PostgreSQL)**: 모든 테스트 관리 데이터(테스트 케이스, 실행 결과, 사용자 정보 등)를 저장합니다.\n    *   **로컬 검색 엔진 (Elasticsearch)**: 테스트 케이스 및 기타 데이터에 대한 고급 검색 및 필터링 기능을 제공합니다.\n    *   **오프라인 캐시 (IndexedDB)**: 네트워크 연결이 불안정하거나 끊겼을 때를 대비하여 핵심 데이터를 로컬에 캐싱합니다.\n*   **AI 서비스 마이크로서비스 (Python)**:\n    *   NLP 모델(HuggingFace) 및 기타 AI 모델을 호스팅하며, REST API를 통해 ITMS 백엔드에 AI 기반 통찰력(예: 케이스 생성 제안, 영향 분석)을 제공합니다.\n*   **외부 시스템 통합**:\n    *   Jira, Redmine, GitLab, GitHub, Jenkins 등 외부 도구들과의 연동을 위한 REST API 클라이언트 및 웹훅 리스너를 포함합니다.\n\n### 최상위 컴포넌트 상호작용 다이어그램\n\n```mermaid\ngraph TD\n    A[ITMS 데스크톱 앱] --> B[내부 백엔드 (Node.js)]\n    B --> C[로컬 PostgreSQL DB]\n    B --> D[로컬 Elasticsearch]\n    B --> E[AI 서비스 (Python)]\n    B --> F[외부 시스템 API (Jira, GitLab 등)]\n    A --> G[IndexedDB (오프라인 캐시)]\n    F --> H[외부 시스템 (Jira, GitLab 등)]\n```\n\n*   **ITMS 데스크톱 앱**은 사용자 인터페이스를 제공하며, 모든 사용자 상호작용은 **내부 백엔드 (Node.js)**를 통해 처리됩니다.\n*   **내부 백엔드**는 **로컬 PostgreSQL DB**에 데이터를 저장하고, **로컬 Elasticsearch**를 통해 검색 기능을 활용합니다.\n*   **내부 백엔드**는 **AI 서비스 (Python)**와 통신하여 지능형 기능을 활용하며, **외부 시스템 API**를 통해 **외부 시스템**과 데이터를 교환합니다.\n*   **ITMS 데스크톱 앱**은 **IndexedDB**를 사용하여 오프라인 환경에서도 데이터에 접근하고 변경 사항을 캐싱합니다.\n\n### 코드 구성 및 규칙\n**도메인 중심 조직 전략**\n*   **도메인 분리**: 비즈니스 도메인/바운디드 컨텍스트(예: `users`, `testcases`, `executions`, `defects`, `integrations`)별로 코드를 구성합니다. 각 도메인은 자체적인 모델, 서비스, 컨트롤러(또는 핸들러)를 가집니다.\n*   **계층 기반 아키텍처**: 관심사를 프레젠테이션, 비즈니스 로직, 데이터 접근, 인프라 계층으로 분리합니다.\n    *   `presentation`: UI 컴포넌트, 라우팅.\n    *   `application`: 비즈니스 로직, 유스케이스 구현.\n    *   `domain`: 핵심 비즈니스 엔티티, 값 객체, 도메인 서비스.\n    *   `infrastructure`: 데이터베이스 접근, 외부 서비스 통합, 유틸리티.\n*   **기능 기반 모듈**: 특정 기능(예: `TestExecutionModule`, `DefectIntegrationModule`)과 관련된 모든 파일을 하나의 디렉토리에 그룹화하여 응집도를 높입니다.\n*   **공유 컴포넌트**: 공통 유틸리티, 타입 정의, 재사용 가능한 UI 컴포넌트 등은 별도의 `shared` 모듈에 배치합니다.\n\n**범용 파일 및 폴더 구조**\n\n```\n/\n├── src/\n│   ├── main/                       # Electron Main Process (Node.js 백엔드)\n│   │   ├── app/                    # 애플리케이션 핵심 로직\n│   │   │   ├── domains/            # 도메인별 모듈 (예: testcases, executions, defects)\n│   │   │   │   ├── testcases/\n│   │   │   │   │   ├── models/\n│   │   │   │   │   ├── services/\n│   │   │   │   │   ├── controllers/\n│   │   │   │   │   └── repositories/\n│   │   │   │   ├── ...\n│   │   │   ├── infrastructure/     # DB 연결, 외부 API 클라이언트, 유틸리티\n│   │   │   │   ├── database/\n│   │   │   │   ├── integrations/\n│   │   │   │   ├── security/\n│   │   │   │   └── utils/\n│   │   │   ├── shared/             # 공통 타입, 상수 등\n│   │   │   └── app.ts              # Express 앱 초기화\n│   │   ├── electron/               # Electron Main Process 관련 파일\n│   │   │   ├── main.ts             # Electron 메인 엔트리 포인트\n│   │   │   └── preload.ts          # Preload 스크립트\n│   │   └── index.ts                # 백엔드 서버 시작점\n│   │\n│   ├── renderer/                   # Electron Renderer Process (React 프론트엔드)\n│   │   ├── assets/                 # 이미지, 아이콘 등\n│   │   ├── components/             # 재사용 가능한 UI 컴포넌트\n│   │   │   ├── common/\n│   │   │   └── shared/\n│   │   ├── features/               # 기능별 모듈 (예: TestCaseManagement, TestExecution)\n│   │   │   ├── TestCaseManagement/\n│   │   │   │   ├── components/\n│   │   │   │   ├── hooks/\n│   │   │   │   ├── pages/\n│   │   │   │   └── store/          # Redux 모듈 (slice, selectors)\n│   │   │   ├── ...\n│   │   ├── hooks/                  # 전역적으로 사용되는 React Hooks\n│   │   ├── store/                  # Redux Root Store 설정\n│   │   ├── styles/                 # 전역 스타일, 테마\n│   │   ├── utils/                  # 프론트엔드 유틸리티 함수\n│   │   └── index.tsx               # React 앱 엔트리 포인트\n│   │\n│   ├── ai-service/                 # AI 서비스 (Python)\n│   │   ├── app.py                  # Flask/FastAPI 앱\n│   │   ├── models/                 # AI 모델 파일\n│   │   ├── services/               # AI 로직\n│   │   └── requirements.txt\n│   │\n│   └── types/                      # 전역 타입 정의 (TypeScript)\n│\n├── config/                         # 환경 설정 파일\n├── scripts/                        # 빌드, 배포 스크립트\n├── tests/                          # 테스트 파일\n├── package.json\n├── tsconfig.json\n├── .env\n└── README.md\n```\n\n### 데이터 흐름 및 통신 패턴\n*   **클라이언트-서버 통신**:\n    *   Electron Renderer (프론트엔드)는 Electron Main Process (Node.js 백엔드)가 제공하는 내부 REST API 엔드포인트와 통신합니다.\n    *   `fetch` API 또는 `axios`와 같은 HTTP 클라이언트 라이브러리를 사용하여 JSON 형식으로 데이터를 주고받습니다.\n*   **데이터베이스 상호작용**:\n    *   Node.js 백엔드는 `pg` (PostgreSQL 클라이언트) 또는 TypeORM/Sequelize와 같은 ORM을 사용하여 PostgreSQL 데이터베이스와 상호작용합니다.\n    *   데이터베이스 쿼리는 서비스 계층에서 추상화되어 비즈니스 로직과 분리됩니다.\n*   **외부 서비스 통합**:\n    *   Node.js 백엔드는 외부 시스템(Jira, Redmine 등)의 REST API를 호출하여 데이터를 가져오거나 업데이트합니다.\n    *   웹훅(Webhook)을 통해 외부 시스템으로부터 실시간 업데이트를 수신할 수 있도록 웹훅 리스너를 구현합니다.\n*   **실시간 통신**:\n    *   ITMS 내부 컴포넌트 간 또는 AI 서비스와의 고성능 통신을 위해 gRPC를 활용할 수 있습니다. 특히 대량의 데이터 스트리밍이나 저지연 통신이 필요한 경우에 유용합니다.\n    *   주요 이벤트(예: 테스트 실행 완료, 결함 상태 변경)에 대한 인앱 알림은 Electron의 IPC(Inter-Process Communication)를 통해 프론트엔드로 전달됩니다.\n*   **데이터 동기화**:\n    *   오프라인 모드를 위해 IndexedDB에 데이터를 캐싱하고, 네트워크 연결이 복구되면 백엔드와 자동 동기화하는 전략을 구현합니다. 충돌 해결 전략(예: Last-Write-Wins 또는 사용자 선택)을 고려합니다.\n    *   외부 시스템과의 양방향 동기화는 주기적인 폴링(Polling) 또는 웹훅 기반의 이벤트 드리븐 방식으로 구현하여 데이터 일관성을 유지합니다.\n\n## 4. 성능 및 최적화 전략\n\n*   **지연 로딩 및 코드 분할**: 애플리케이션 시작 시간을 단축하고 메모리 사용량을 최적화하기 위해 Electron 및 React 애플리케이션에서 필요한 모듈과 컴포넌트를 지연 로딩(Lazy Loading)하고 코드 분할(Code Splitting)을 적용합니다.\n*   **데이터 캐싱 및 최적화된 쿼리**: 자주 접근하는 데이터는 IndexedDB에 캐싱하여 UI 응답 속도를 높이고, 데이터베이스 쿼리는 인덱싱 및 최적화를 통해 대량 데이터 처리 성능을 향상시킵니다. Elasticsearch를 활용하여 복잡한 검색 쿼리의 성능을 보장합니다.\n*   **가상화된 리스트/테이블**: 대량의 테스트 케이스나 실행 결과 목록을 표시할 때, 모든 항목을 한 번에 렌더링하는 대신 화면에 보이는 부분만 렌더링하는 가상화(Virtualization) 기법을 사용하여 UI 성능을 최적화합니다.\n*   **백그라운드 처리 및 비동기 작업**: 시간이 오래 걸리는 작업(예: 대량 데이터 임포트, AI 모델 추론)은 메인 스레드를 블록하지 않도록 백그라운드에서 비동기적으로 처리하고, 사용자에게 진행 상황을 시각적으로 피드백합니다.\n\n## 5. 구현 로드맵 및 마일스톤\n\n### 1단계: 기반 (MVP 구현)\n*   **핵심 인프라**: Electron 앱 구조 설정, Node.js 백엔드 및 PostgreSQL DB 연동, 기본 인증/권한 관리(로컬 계정).\n*   **필수 기능**:\n    *   테스트 케이스 관리 (CRUD, 버전 이력, 검색/필터).\n    *   릴리즈 및 스위트 계획 (생성, 케이스 할당).\n    *   테스트 실행 및 결과 기록 (Pass/Fail/Blocked/Untested, 상세 기록).\n    *   Jira/Redmine 연동 (단방향 결함 생성).\n    *   기본 대시보드 및 보고서 (고정 위젯).\n    *   기본 협업 기능 (댓글, @멘션).\n*   **기본 보안**: 사용자 비밀번호 해싱, TLS 1.3 통신, 기본적인 입력 유효성 검사.\n*   **개발 환경 설정**: 개발/테스트/운영 환경 구성, Git 저장소 설정, 기본 CI/CD 파이프라인 (빌드 및 테스트).\n*   **예상 완료 기간**: 12주\n\n### 2단계: 기능 강화\n*   **고급 기능**:\n    *   Jira/Redmine 양방향 상태 동기화.\n    *   사용자 및 역할 관리 (RBAC, SSO 연동).\n    *   고급 검색 및 필터링 (Elasticsearch 연동).\n    *   오프라인 실행 및 자동 동기화.\n    *   알림 센터 (인앱 + 이메일).\n    *   테스트 데이터 관리 경량화 (변수 참조).\n    *   테스트 케이스 복사/이동.\n*   **성능 최적화**: UI 응답 속도 개선 (가상화, 지연 로딩), 대량 임포트 성능 최적화.\n*   **강화된 보안**: OWASP Top 10 준수, 민감 데이터 암호화 (저장 시).\n*   **모니터링 구현**: 애플리케이션 로깅, 성능 지표 수집.\n*   **예상 완료 기간**: 8주\n\n### 3단계: 확장 및 최적화\n*   **확장성 구현**: 1백만 케이스, 500명 동시 사용자 지원을 위한 아키텍처 개선 및 성능 튜닝.\n*   **고급 통합**: GitLab/GitHub 웹훅 연동 (커밋 기반 영향 분석), CI 도구(Jenkins) 플러그인 SDK 연동.\n*   **엔터프라이즈 기능**:\n    *   AI 기반 케이스 생성 제안 (NLP + AST).\n    *   AI 기반 영향 분석 및 회귀 스위트 추천.\n    *   AI 기반 실패 핫스팟 예측.\n    *   위험 기반 테스트 우선순위 보고서.\n    *   사용자 정의 위젯/차트 대시보드.\n    *   릴리즈 건강 지표.\n*   **규정 준수 및 감사**: 데이터 감사 로그, 규정 준수 보고서 지원.\n*   **예상 완료 기간**: 12주\n\n## 6. 위험 평가 및 완화 전략\n\n### 기술 위험 분석\n*   **기술 위험**: Electron 앱의 성능 저하 및 메모리 사용량 증가.\n    *   **완화 전략**: 코드 분할, 지연 로딩, 가상화된 리스트/테이블 적용, 메모리 프로파일링 및 최적화, 주기적인 Electron 및 Node.js 버전 업데이트.\n*   **성능 위험**: 대량 데이터 처리 및 동시 사용자 증가 시 시스템 응답 지연.\n    *   **완화 전략**: PostgreSQL 쿼리 최적화 및 인덱싱, Elasticsearch 클러스터 튜닝, 백그라운드 작업 처리, 캐싱 전략 강화, 부하 테스트를 통한 병목 현상 사전 식별.\n*   **보안 위험**: 민감 데이터 유출 및 무단 접근.\n    *   **완화 전략**: 모든 민감 데이터(비밀번호, API 키)는 암호화하여 저장하고, 전송 시 TLS 1.3 암호화 적용. 역할 기반 접근 제어(RBAC)를 엄격하게 구현하고, 정기적인 보안 취약점 점검 및 코드 리뷰 수행.\n*   **통합 위험**: 외부 서비스(Jira, GitLab 등) API 변경으로 인한 연동 문제.\n    *   **완화 전략**: 외부 API 연동을 위한 어댑터 계층을 구현하여 외부 변경에 대한 의존성을 최소화. 주요 통합 기능에 대한 자동화된 통합 테스트를 주기적으로 실행.\n\n### 프로젝트 제공 위험\n*   **일정 위험**: 복잡한 기능(AI, 실시간 동기화) 개발 지연.\n    *   **완화 전략**: 기능별 MVP를 정의하고 점진적으로 개발. 각 마일스톤별로 명확한 목표와 산출물을 설정하고, 정기적인 진행 상황 검토 및 위험 식별 회의 진행.\n*   **자원 위험**: AI/ML 전문 인력 부족.\n    *   **완화 전략**: 초기에는 HuggingFace와 TensorFlow Lite의 기존 모델을 활용하고, 필요시 외부 전문가 자문 또는 교육을 통해 내부 역량 강화.\n*   **품질 위험**: 데스크톱 앱의 호환성 및 안정성 문제.\n    *   **완화 전략**: 다양한 운영체제(Windows 10/11) 및 환경에서 철저한 테스트 수행. 자동화된 유닛, 통합, E2E 테스트 커버리지 확대. 베타 테스트 프로그램을 통해 실제 사용자 피드백 조기 수집.\n*   **배포 위험**: 자동 업데이트 실패 또는 설치 문제.\n    *   **완화 전략**: Electron auto-updater의 안정성 검증 및 MSI installer의 배포 프로세스 자동화. 롤백 계획을 수립하고, 단계적 배포(Canary Release)를 고려하여 위험 최소화.",
      "writedAt": "2025-07-23T05:34:58.140Z"
    },
    {
      "type": "guideline",
      "content": "# ITMS (지능형 테스트 관리 시스템) 코드 가이드라인\n\n## 1. 프로젝트 개요\n\nITMS는 테스트 계획, 실행, 결과 추적 및 결함 관리를 위한 데스크톱 애플리케이션입니다. 사용자 친화적인 UX와 AI 기반 통찰력을 결합하여 QA 생산성을 높이고 소프트웨어 품질을 향상하며 팀 간 협업을 개선하는 것을 목표로 합니다.\n\n본 프로젝트의 핵심 기술 스택 및 아키텍처 결정은 다음과 같습니다:\n\n*   **프런트엔드**: Electron (데스크톱 앱), React (UI 프레임워크)\n*   **백엔드**: Node.js (데스크톱 앱 내장), Go (마이크로서비스 API)\n*   **데이터베이스**: PostgreSQL (관계형 데이터), Elasticsearch (검색)\n*   **AI 서비스**: Python (HuggingFace, TensorFlow Lite)\n*   **통신**: gRPC (실시간 동기화), REST API (통합)\n\n아키텍처는 Electron 기반의 데스크톱 애플리케이션이 주축을 이루며, 내장된 Node.js 백엔드를 통해 로컬 데이터 처리 및 Electron API 접근을 수행합니다. 복잡한 비즈니스 로직 및 외부 시스템 연동은 Go 기반의 마이크로서비스 API를 통해 처리하며, AI 기능은 Python 마이크로서비스로 분리됩니다. 데이터 동기화 및 실시간 통신을 위해 gRPC를 적극 활용하고, 외부 통합은 REST API를 통해 이루어집니다.\n\n## 2. 핵심 원칙\n\n1.  **명확성**: 코드는 의도를 명확히 드러내어 쉽게 이해할 수 있어야 합니다.\n2.  **모듈화**: 각 컴포넌트, 모듈은 단일 책임을 가지며 재사용 가능해야 합니다.\n3.  **견고성**: 예외 상황을 예측하고 적절히 처리하여 시스템의 안정성을 보장해야 합니다.\n4.  **성능 최적화**: 사용자 경험을 저해하지 않도록 UI 응답 및 데이터 처리 성능을 최적화해야 합니다.\n5.  **보안 우선**: 모든 계층에서 보안 취약점을 최소화하고 데이터 보호를 최우선으로 고려해야 합니다.\n\n## 3. 언어별 가이드라인\n\n### 3.1. JavaScript/TypeScript (Electron & React)\n\n#### 파일 구성 및 디렉터리 구조\n\n*   **MUST**: `src` 디렉터리 아래에 기능별/도메인별로 디렉터리를 구성합니다.\n*   **MUST**: 각 기능 디렉터리 내에는 `components`, `hooks`, `services`, `utils`, `store` 등 역할별 하위 디렉터리를 가집니다.\n*   **MUST**: React 컴포넌트는 JSX/TSX 파일을 사용하고, 로직 분리를 위해 커스텀 훅은 `.ts` 파일을 사용합니다.\n*   **MUST NOT**: 단일 파일에 여러 개의 컴포넌트나 모듈을 정의하여 파일의 길이가 과도하게 길어지는 것을 피합니다.\n\n```\n// MUST: 명확하고 구조화된 디렉터리 구조\nsrc/\n├── main/             // Electron Main Process\n│   └── index.ts\n├── renderer/         // Electron Renderer Process (React App)\n│   ├── app/\n│   │   ├── App.tsx\n│   │   └── index.tsx\n│   ├── features/\n│   │   ├── test-case-management/\n│   │   │   ├── components/\n│   │   │   │   ├── TestCaseList.tsx\n│   │   │   │   └── TestCaseEditor.tsx\n│   │   │   ├── hooks/\n│   │   │   │   └── useTestCases.ts\n│   │   │   ├── services/\n│   │   │   │   └── testCaseService.ts\n│   │   │   └── store/\n│   │   │       └── testCaseStore.ts\n│   ├── shared/       // 공통 컴포넌트, 유틸리티 등\n│   │   ├── components/\n│   │   └── utils/\n│   └── types/        // 전역 타입 정의\n│       └── index.d.ts\n└── preload/          // Electron Preload Script\n    └── index.ts\n```\n\n#### 임포트/의존성 관리\n\n*   **MUST**: 절대 경로 임포트를 사용하여 가독성을 높입니다. (예: `import { Button } from '@/shared/components/Button';`)\n*   **MUST**: 외부 라이브러리 임포트, 내부 모듈 임포트, 상대 경로 임포트 순으로 그룹화하고 각 그룹 사이에 빈 줄을 추가합니다.\n*   **MUST**: 필요한 모듈만 명시적으로 임포트합니다. (Named Import 선호)\n\n```typescript\n// MUST: 임포트 순서 및 그룹화\nimport React from 'react';\nimport { useQuery } from '@tanstack/react-query'; // 외부 라이브러리\n\nimport { TestCase } from '@/types'; // 내부 모듈\nimport { fetchTestCases } from '@/features/test-case-management/services/testCaseService'; // 내부 모듈\n\nimport { TestCaseItem } from './components/TestCaseItem'; // 상대 경로\n\n// ...\n```\n\n#### 에러 핸들링 패턴\n\n*   **MUST**: 비동기 작업은 `try-catch` 블록을 사용하여 에러를 명시적으로 처리합니다.\n*   **MUST**: 사용자에게 의미 있는 에러 메시지를 제공하고, 개발자에게는 상세한 로그를 남깁니다.\n*   **MUST**: 전역 에러 바운더리(Error Boundary)를 사용하여 React 컴포넌트 트리의 에러를 처리합니다.\n*   **MUST NOT**: 에러를 단순히 무시하거나 콘솔에만 출력하고 사용자에게 알리지 않는 것을 피합니다.\n\n```typescript\n// MUST: 비동기 에러 핸들링 및 사용자 피드백\nasync function loadTestCases() {\n    try {\n        const cases = await testCaseService.fetchTestCases();\n        setTestCases(cases);\n    } catch (error) {\n        console.error('테스트 케이스 로드 실패:', error);\n        // 사용자에게 에러 메시지 표시\n        alert('테스트 케이스를 불러오는 데 실패했습니다. 다시 시도해 주세요.');\n    }\n}\n\n// MUST NOT: 에러 무시\nasync function saveUserData(data: UserData) {\n    userService.save(data).catch(console.error); // 에러를 단순히 콘솔에만 출력하고 사용자에게 알리지 않음\n}\n```\n\n### 3.2. Go (마이크로서비스 API)\n\n#### 파일 구성 및 디렉터리 구조\n\n*   **MUST**: 표준 Go 프로젝트 레이아웃을 따릅니다. (`cmd`, `pkg`, `internal`, `api`, `configs`, `docs`, `build` 등)\n*   **MUST**: `internal` 디렉터리에는 외부 패키지에서 임포트할 수 없는 애플리케이션 전용 코드를 배치합니다.\n*   **MUST**: `pkg` 디렉터리에는 외부 프로젝트에서 사용될 수 있는 라이브러리 코드를 배치합니다.\n*   **MUST NOT**: 모든 코드를 루트 디렉터리에 두거나, 패키지 간의 순환 의존성을 만듭니다.\n\n```\n// MUST: 표준 Go 프로젝트 레이아웃\nproject-name/\n├── cmd/             // 메인 애플리케이션 엔트리 포인트\n│   └── server/\n│       └── main.go\n├── pkg/             // 외부에서 재사용 가능한 라이브러리 코드\n│   └── utils/\n│       └── validator.go\n├── internal/        // 프로젝트 내부 전용 코드\n│   ├── app/\n│   │   ├── handler/\n│   │   │   └── testcase_handler.go\n│   │   ├── repository/\n│   │   │   └── testcase_repo.go\n│   │   └── service/\n│   │       └── testcase_service.go\n│   ├── config/\n│   │   └── config.go\n│   └── model/\n│       └── testcase.go\n├── api/             // Protobuf 정의 등 API 명세\n│   └── proto/\n│       └── testcase.proto\n├── configs/         // 설정 파일\n├── docs/            // 문서\n└── go.mod\n```\n\n#### 임포트/의존성 관리\n\n*   **MUST**: Go 모듈을 사용하여 의존성을 관리합니다.\n*   **MUST**: 표준 라이브러리, 외부 라이브러리, 내부 프로젝트 패키지 순으로 임포트를 그룹화하고 각 그룹 사이에 빈 줄을 추가합니다.\n*   **MUST**: 사용하지 않는 임포트는 제거합니다. (`goimports` 도구 사용 권장)\n\n```go\n// MUST: 임포트 순서 및 그룹화\nimport (\n\t\"context\"\n\t\"fmt\" // 표준 라이브러리\n\n\t\"github.com/gin-gonic/gin\" // 외부 라이브러리\n\t\"google.golang.org/grpc\"   // 외부 라이브러리\n\n\t\"itms/internal/app/service\" // 내부 프로젝트 패키지\n\t\"itms/internal/config\"      // 내부 프로젝트 패키지\n)\n```\n\n#### 에러 핸들링 패턴\n\n*   **MUST**: 에러는 마지막 반환 값으로 명시적으로 반환합니다.\n*   **MUST**: 에러 메시지는 구체적이고 디버깅에 유용하도록 작성합니다.\n*   **MUST**: 에러 래핑(`fmt.Errorf(\"%w\", err)`)을 사용하여 에러 스택 트레이스를 보존합니다.\n*   **MUST NOT**: 에러를 무시하거나, `panic`을 비정상적인 종료가 아닌 일반적인 에러 처리 흐름에 사용하지 않습니다.\n\n```go\n// MUST: 에러 반환 및 래핑\nfunc (s *testCaseService) GetTestCase(ctx context.Context, id string) (*model.TestCase, error) {\n    testCase, err := s.repo.FindByID(ctx, id)\n    if err != nil {\n        // 에러 래핑을 통해 원본 에러 정보 유지\n        return nil, fmt.Errorf(\"테스트 케이스 조회 실패: %w\", err)\n    }\n    if testCase == nil {\n        return nil, fmt.Errorf(\"테스트 케이스를 찾을 수 없습니다: %s\", id)\n    }\n    return testCase, nil\n}\n\n// MUST NOT: 에러 무시\nfunc processData(data []byte) {\n    _, err := json.Unmarshal(data, &someStruct)\n    // if err != nil { ... } 에러 처리 누락\n}\n```\n\n### 3.3. Python (AI 서비스)\n\n#### 파일 구성 및 디렉터리 구조\n\n*   **MUST**: 모듈화된 패키지 구조를 따릅니다. (`src` 또는 프로젝트 이름의 최상위 패키지)\n*   **MUST**: AI 모델, 데이터 처리, API 엔드포인트 등 역할별로 디렉터리를 분리합니다.\n*   **MUST**: 각 디렉터리에는 `__init__.py` 파일을 포함하여 패키지로 인식되도록 합니다.\n\n```\n// MUST: Python 패키지 구조\nai-service/\n├── src/\n│   ├── __init__.py\n│   ├── api/          // FastAPI 엔드포인트\n│   │   ├── __init__.py\n│   │   └── routes.py\n│   ├── models/       // AI 모델 정의 및 로딩\n│   │   ├── __init__.py\n│   │   └── nlp_model.py\n│   ├── processing/   // 데이터 전처리 및 후처리\n│   │   ├── __init__.py\n│   │   └── text_processor.py\n│   └── core/         // 핵심 비즈니스 로직\n│       ├── __init__.py\n│       └── inference.py\n├── tests/            // 테스트 코드\n├── requirements.txt  // 의존성 관리\n└── main.py           // 애플리케이션 엔트리 포인트\n```\n\n#### 임포트/의존성 관리\n\n*   **MUST**: `requirements.txt` 또는 `pyproject.toml`을 사용하여 의존성을 명시적으로 관리합니다.\n*   **MUST**: 절대 임포트(`from package.module import ...`)를 선호하고, 상대 임포트(`from .module import ...`)는 동일 패키지 내에서만 사용합니다.\n*   **MUST**: 임포트 순서는 표준 라이브러리, 서드파티 라이브러리, 로컬 애플리케이션 모듈 순으로 그룹화합니다.\n\n```python\n# MUST: 임포트 순서 및 그룹화\nimport os\nimport json # 표준 라이브러리\n\nfrom fastapi import FastAPI # 서드파티 라이브러리\nfrom transformers import pipeline # 서드파티 라이브러리\n\nfrom src.models.nlp_model import load_nlp_model # 로컬 애플리케이션 모듈\nfrom src.processing.text_processor import preprocess_text # 로컬 애플리케이션 모듈\n```\n\n#### 에러 핸들링 패턴\n\n*   **MUST**: `try-except` 블록을 사용하여 예외를 처리하고, 구체적인 예외 타입을 명시합니다.\n*   **MUST**: 사용자에게는 일반적인 에러 메시지를, 로그에는 상세한 스택 트레이스를 기록합니다.\n*   **MUST**: FastAPI 사용 시 `HTTPException`을 활용하여 HTTP 응답으로 에러를 반환합니다.\n*   **MUST NOT**: 광범위한 `except Exception:`을 남용하여 예상치 못한 에러를 숨기지 않습니다.\n\n```python\n# MUST: 구체적인 예외 처리 및 로깅\nfrom fastapi import HTTPException, status\nimport logging\n\nlogger = logging.getLogger(__name__)\n\nasync def generate_test_cases(text: str):\n    try:\n        processed_text = preprocess_text(text)\n        model = load_nlp_model()\n        results = model(processed_text)\n        return {\"results\": results}\n    except ValueError as e:\n        logger.error(f\"입력 값 오류: {e}\")\n        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=f\"잘못된 입력: {e}\")\n    except Exception as e:\n        logger.exception(\"테스트 케이스 생성 중 알 수 없는 오류 발생\") # 상세 스택 트레이스 로깅\n        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=\"내부 서버 오류가 발생했습니다.\")\n\n# MUST NOT: 광범위한 예외 처리\ndef some_function():\n    try:\n        # ...\n    except Exception: # 모든 예외를 잡아서 디버깅을 어렵게 함\n        pass\n```\n\n## 4. 코드 스타일 규칙\n\n### 4.1. MUST Follow (필수 준수 사항)\n\n*   **일관된 명명 규칙**:\n    *   **Rationale**: 코드의 가독성을 높이고 의미를 명확하게 전달합니다.\n    *   **JavaScript/TypeScript**:\n        *   변수, 함수: `camelCase` (예: `userName`, `getUserData`)\n        *   클래스, 컴포넌트, 타입: `PascalCase` (예: `UserComponent`, `IUserData`)\n        *   상수: `SCREAMING_SNAKE_CASE` (예: `MAX_RETRIES`)\n    *   **Go**:\n        *   변수, 함수, 패키지: `camelCase` (내보내지 않는 경우), `PascalCase` (내보내는 경우) (예: `userName`, `GetUserData`)\n        *   상수: `PascalCase` 또는 `SCREAMING_SNAKE_CASE` (예: `MaxRetries`, `MAX_RETRIES`)\n    *   **Python**:\n        *   변수, 함수, 모듈: `snake_case` (예: `user_name`, `get_user_data`)\n        *   클래스: `PascalCase` (예: `UserProcessor`)\n        *   상수: `SCREAMING_SNAKE_CASE` (예: `MAX_RETRIES`)\n\n*   **들여쓰기**:\n    *   **Rationale**: 코드의 구조를 시각적으로 명확하게 구분합니다.\n    *   **모든 언어**: 4칸 공백을 사용합니다. 탭 문자는 사용하지 않습니다.\n\n*   **주석**:\n    *   **Rationale**: 코드의 복잡한 로직, 비즈니스 규칙, 의도 등을 설명하여 유지보수성을 높입니다.\n    *   **MUST**: 공개 API, 복잡한 알고리즘, 비즈니스 로직의 핵심 부분에는 주석을 작성합니다.\n    *   **MUST**: Go에서는 공개 함수 및 타입에 GoDoc 형식의 주석을 작성합니다.\n    *   **MUST NOT**: 자명한 코드에 주석을 달거나, 코드 내용을 그대로 반복하는 주석은 피합니다.\n\n```go\n// MUST: GoDoc 주석 예시\n// GetTestCase retrieves a test case by its ID.\n// It returns the TestCase object and an error if the test case is not found or an\n// internal error occurs during retrieval.\nfunc (s *testCaseService) GetTestCase(ctx context.Context, id string) (*model.TestCase, error) {\n    // ...\n}\n```\n\n*   **코드 길이 및 복잡성**:\n    *   **Rationale**: 함수와 파일의 길이를 적절히 유지하여 가독성과 테스트 용이성을 높입니다.\n    *   **MUST**: 함수는 단일 책임을 가지도록 작게 유지합니다. (이상적으로 50줄 이내)\n    *   **MUST**: 파일당 코드 길이는 500줄을 초과하지 않도록 노력합니다. (예외: 타입 정의 파일 등)\n    *   **MUST**: 순환 복잡도(Cyclomatic Complexity)를 낮게 유지합니다.\n\n*   **타입 정의 (TypeScript, Go, Python Type Hinting)**:\n    *   **Rationale**: 코드의 안정성을 높이고, 개발 과정에서 오류를 조기에 발견하며, 코드 자동 완성 및 리팩토링을 용이하게 합니다.\n    *   **MUST**: 모든 함수 매개변수, 반환 값, 변수에 명시적인 타입을 선언합니다.\n    *   **MUST**: 복잡한 데이터 구조는 인터페이스(TypeScript), 구조체(Go), 데이터 클래스/TypedDict(Python)로 정의합니다.\n\n```typescript\n// MUST: TypeScript 타입 정의\ninterface TestCase {\n    id: string;\n    title: string;\n    priority: 'High' | 'Medium' | 'Low';\n    steps: string[];\n}\n\nfunction createTestCase(data: Omit<TestCase, 'id'>): TestCase {\n    // ...\n}\n```\n\n### 4.2. MUST NOT Do (금지 사항)\n\n*   **매직 넘버/문자열 사용 금지**:\n    *   **Rationale**: 코드의 의미를 불분명하게 만들고, 변경 시 오류를 유발할 수 있습니다.\n    *   **MUST NOT**: 의미 있는 상수 대신 하드코딩된 숫자나 문자열을 사용합니다.\n    *   **MUST**: 모든 매직 넘버/문자열은 명명된 상수로 정의하여 사용합니다.\n\n```typescript\n// MUST NOT: 매직 넘버 사용\nif (status === 200) { /* ... */ }\n\n// MUST: 상수 사용\nconst HTTP_STATUS_OK = 200;\nif (status === HTTP_STATUS_OK) { /* ... */ }\n```\n\n*   **전역 변수 남용 금지**:\n    *   **Rationale**: 코드의 예측 불가능성을 높이고, 사이드 이펙트를 유발하며, 테스트를 어렵게 만듭니다.\n    *   **MUST NOT**: 불필요하게 전역 변수를 선언하고 사용합니다.\n    *   **MUST**: 상태 관리는 Redux (React), Context API (React), 또는 Go/Python의 서비스 계층을 통해 명시적으로 관리합니다.\n\n*   **복잡한 조건문/중첩 루프**:\n    *   **Rationale**: 코드의 가독성을 저해하고, 오류 발생 가능성을 높입니다.\n    *   **MUST NOT**: 3단계 이상 중첩된 조건문이나 루프를 사용합니다.\n    *   **MUST**: 함수 분리, 가드 절(Guard Clause) 사용, 디자인 패턴 적용 등을 통해 복잡성을 줄입니다.\n\n```typescript\n// MUST NOT: 과도한 중첩\nfunction processData(data: any) {\n    if (data) {\n        if (data.items) {\n            for (const item of data.items) {\n                if (item.isValid) {\n                    // ... 복잡한 로직\n                }\n            }\n        }\n    }\n}\n\n// MUST: 가드 절 및 함수 분리\nfunction processData(data: any) {\n    if (!data || !data.items) {\n        return;\n    }\n    for (const item of data.items) {\n        processItem(item);\n    }\n}\n\nfunction processItem(item: any) {\n    if (!item.isValid) {\n        return;\n    }\n    // ... 복잡한 로직\n}\n```\n\n*   **직접적인 DOM 조작 (React)**:\n    *   **Rationale**: React의 선언적 패러다임을 위반하고, 상태 관리와 UI 동기화를 어렵게 만듭니다.\n    *   **MUST NOT**: `document.getElementById`, `querySelector` 등을 사용하여 React 컴포넌트 내부에서 직접 DOM을 조작합니다.\n    *   **MUST**: `useState`, `useRef`, 또는 라이브러리(예: React DnD)를 통해 React의 상태 관리 및 참조 시스템을 활용합니다.\n\n## 5. 아키텍처 패턴\n\n### 5.1. 컴포넌트/모듈 구조 가이드라인\n\n*   **단일 책임 원칙 (SRP)**:\n    *   **Rationale**: 각 컴포넌트/모듈은 하나의 책임만 가지도록 설계하여 재사용성, 테스트 용이성, 유지보수성을 높입니다.\n    *   **React**: UI 컴포넌트는 UI 렌더링에만 집중하고, 데이터 페칭이나 복잡한 로직은 커스텀 훅이나 서비스 레이어로 분리합니다.\n    *   **Go/Python**: 서비스, 리포지토리, 핸들러 등 계층별로 명확히 책임을 분리합니다.\n\n*   **계층형 아키텍처**:\n    *   **Rationale**: 각 계층은 명확한 역할을 가지며, 의존성은 상위 계층에서 하위 계층으로만 흐르도록 하여 시스템의 응집도를 높입니다.\n    *   **프런트엔드**: Presentational/Container 패턴 또는 Atomic Design 원칙을 적용하여 컴포넌트를 구성합니다.\n    *   **백엔드**: Controller/Handler -> Service -> Repository/Data Access Object (DAO) 계층으로 구성합니다.\n\n### 5.2. 데이터 흐름 패턴\n\n*   **단방향 데이터 흐름 (React)**:\n    *   **Rationale**: React의 핵심 원칙으로, 상태 변화를 예측 가능하게 하고 디버깅을 용이하게 합니다.\n    *   **MUST**: 부모 컴포넌트에서 자식 컴포넌트로 데이터를 Props를 통해 전달합니다.\n    *   **MUST NOT**: 자식 컴포넌트가 부모 컴포넌트의 상태를 직접 수정하는 것을 금지합니다. (콜백 함수를 통해 부모 상태 업데이트 요청)\n\n*   **데이터 동기화 (gRPC)**:\n    *   **Rationale**: 실시간 데이터 동기화 및 오프라인 모드 지원을 위해 효율적인 통신을 보장합니다.\n    *   **MUST**: 클라이언트(Electron Node.js)와 서버(Go 마이크로서비스) 간 실시간 통신은 gRPC를 사용합니다.\n    *   **MUST**: Protobuf를 사용하여 데이터 스키마를 정의하고 관리합니다.\n    *   **MUST**: 오프라인 모드 시 IndexedDB에 데이터를 캐싱하고, 네트워크 재연결 시 gRPC를 통해 서버와 자동 동기화합니다.\n\n### 5.3. 상태 관리 컨벤션 (React)\n\n*   **글로벌 상태 관리**:\n    *   **Rationale**: 애플리케이션 전반에 걸쳐 공유되는 상태를 일관되고 효율적으로 관리합니다.\n    *   **MUST**: Redux Toolkit을 사용하여 전역 상태를 관리합니다.\n    *   **MUST**: Slice 패턴을 사용하여 각 도메인별 상태를 모듈화합니다. (예: `testCasesSlice`, `usersSlice`)\n    *   **MUST**: Redux Thunk 또는 Redux Saga를 사용하여 비동기 로직을 처리합니다.\n\n*   **로컬 컴포넌트 상태**:\n    *   **Rationale**: 특정 컴포넌트에만 국한되는 상태는 불필요한 전역 상태 오염을 방지합니다.\n    *   **MUST**: `useState` 훅을 사용하여 컴포넌트 내부의 로컬 상태를 관리합니다.\n    *   **MUST**: `useReducer` 훅은 복잡한 로컬 상태 로직을 관리할 때 사용합니다.\n\n### 5.4. API 설계 표준\n\n*   **RESTful API (Go)**:\n    *   **Rationale**: 외부 시스템(Jira, Redmine 등)과의 통합을 위해 표준화된 통신 방식을 제공합니다.\n    *   **MUST**: 자원(Resource) 중심의 URL을 설계합니다. (예: `/testcases`, `/defects/{id}`)\n    *   **MUST**: HTTP 메서드(GET, POST, PUT, DELETE)를 자원의 CRUD 작업에 맞게 사용합니다.\n    *   **MUST**: 상태 코드(Status Code)를 적절하게 사용하여 응답의 의미를 명확히 합니다.\n    *   **MUST**: 요청 및 응답 페이로드는 JSON 형식을 사용합니다.\n\n*   **gRPC API (Go)**:\n    *   **Rationale**: 내부 서비스 간의 고성능 통신 및 실시간 동기화를 위해 사용합니다.\n    *   **MUST**: `.proto` 파일에 서비스 정의 및 메시지 구조를 명확히 명시합니다.\n    *   **MUST**: 스트리밍(Streaming) 기능을 활용하여 실시간 업데이트 및 양방향 통신을 구현합니다.\n\n*   **API 버전 관리**:\n    *   **Rationale**: API 변경 시 하위 호환성을 유지하고 클라이언트의 안정적인 사용을 보장합니다.\n    *   **MUST**: URL 기반 버전 관리(`api/v1/testcases`)를 사용합니다.\n\n```protobuf\n// MUST: gRPC Protobuf 서비스 정의 예시\nsyntax = \"proto3\";\n\npackage testcase;\n\noption go_package = \"itms/api/proto/testcase\";\n\nservice TestCaseService {\n  rpc GetTestCase (GetTestCaseRequest) returns (TestCase);\n  rpc CreateTestCase (CreateTestCaseRequest) returns (TestCase);\n  rpc StreamTestCases (StreamTestCasesRequest) returns (stream TestCase); // 스트리밍 예시\n}\n\nmessage TestCase {\n  string id = 1;\n  string title = 2;\n  repeated string steps = 3;\n  string status = 4;\n}\n\nmessage GetTestCaseRequest {\n  string id = 1;\n}\n\nmessage CreateTestCaseRequest {\n  string title = 1;\n  repeated string steps = 2;\n}\n\nmessage StreamTestCasesRequest {\n  string filter = 1;\n}\n```",
      "writedAt": "2025-07-23T05:34:58.140Z"
    },
    {
      "type": "step-by-step",
      "content": "\n## Core Directive\nYou are a senior software engineer AI assistant. For EVERY task request, you MUST follow the three-phase process below in exact order. Each phase must be completed with expert-level precision and detail.\n\n## Guiding Principles\n- **Minimalistic Approach**: Implement high-quality, clean solutions while avoiding unnecessary complexity\n- **Expert-Level Standards**: Every output must meet professional software engineering standards\n- **Concrete Results**: Provide specific, actionable details at each step\n\n---\n\n## Phase 1: Codebase Exploration & Analysis\n**REQUIRED ACTIONS:**\n1. **Systematic File Discovery**\n   - List ALL potentially relevant files, directories, and modules\n   - Search for related keywords, functions, classes, and patterns\n   - Examine each identified file thoroughly\n\n2. **Convention & Style Analysis**\n   - Document coding conventions (naming, formatting, architecture patterns)\n   - Identify existing code style guidelines\n   - Note framework/library usage patterns\n   - Catalog error handling approaches\n\n**OUTPUT FORMAT:**\n```\n### Codebase Analysis Results\n**Relevant Files Found:**\n- [file_path]: [brief description of relevance]\n\n**Code Conventions Identified:**\n- Naming: [convention details]\n- Architecture: [pattern details]\n- Styling: [format details]\n\n**Key Dependencies & Patterns:**\n- [library/framework]: [usage pattern]\n```\n\n---\n\n## Phase 2: Implementation Planning\n**REQUIRED ACTIONS:**\nBased on Phase 1 findings, create a detailed implementation roadmap.\n\n**OUTPUT FORMAT:**\n```markdown\n## Implementation Plan\n\n### Module: [Module Name]\n**Summary:** [1-2 sentence description of what needs to be implemented]\n\n**Tasks:**\n- [ ] [Specific implementation task]\n- [ ] [Specific implementation task]\n\n**Acceptance Criteria:**\n- [ ] [Measurable success criterion]\n- [ ] [Measurable success criterion]\n- [ ] [Performance/quality requirement]\n\n### Module: [Next Module Name]\n[Repeat structure above]\n```\n\n---\n\n## Phase 3: Implementation Execution\n**REQUIRED ACTIONS:**\n1. Implement each module following the plan from Phase 2\n2. Verify ALL acceptance criteria are met before proceeding\n3. Ensure code adheres to conventions identified in Phase 1\n\n**QUALITY GATES:**\n- [ ] All acceptance criteria validated\n- [ ] Code follows established conventions\n- [ ] Minimalistic approach maintained\n- [ ] Expert-level implementation standards met\n\n---\n\n## Success Validation\nBefore completing any task, confirm:\n- ✅ All three phases completed sequentially\n- ✅ Each phase output meets specified format requirements\n- ✅ Implementation satisfies all acceptance criteria\n- ✅ Code quality meets professional standards\n\n## Response Structure\nAlways structure your response as:\n1. **Phase 1 Results**: [Codebase analysis findings]\n2. **Phase 2 Plan**: [Implementation roadmap]  \n3. **Phase 3 Implementation**: [Actual code with validation]\n",
      "writedAt": "2025-07-23T05:34:58.140Z"
    },
    {
      "type": "tdd",
      "content": "\n# TDD Process Guidelines - Cursor Rules\n\n## ⚠️ MANDATORY: Follow these rules for EVERY implementation and modification\n\n**This document defines the REQUIRED process for all code changes. No exceptions without explicit team approval.**\n\n## Core Cycle: Red → Green → Refactor\n\n### 1. RED Phase\n- Write a failing test FIRST\n- Test the simplest scenario\n- Verify test fails for the right reason\n- One test at a time\n\n### 2. GREEN Phase  \n- Write MINIMAL code to pass\n- \"Fake it till you make it\" is OK\n\n- YAGNI principle\n\n### 3. REFACTOR Phase\n- Remove duplication\n- Improve naming\n- Simplify structure\n- Keep tests passing\n\n## Test Quality: FIRST Principles\n- **Fast**: Milliseconds, not seconds\n- **Independent**: No shared state\n- **Repeatable**: Same result every time\n- **Self-validating**: Pass/fail, no manual checks\n- **Timely**: Written just before code\n\n## Test Structure: AAA Pattern\n```\n// Arrange\nSet up test data and dependencies\n\n// Act\nExecute the function/method\n\n// Assert\nVerify expected outcome\n```\n\n## Implementation Flow\n1. **List scenarios** before coding\n2. **Pick one scenario** → Write test\n3. **Run test** → See it fail (Red)\n4. **Implement** → Make it pass (Green)\n5. **Refactor** → Clean up (Still Green)\n6. **Commit** → Small, frequent commits\n7. **Repeat** → Next scenario\n\n## Test Pyramid Strategy\n- **Unit Tests** (70%): Fast, isolated, numerous\n- **Integration Tests** (20%): Module boundaries\n- **Acceptance Tests** (10%): User scenarios\n\n## Outside-In vs Inside-Out\n- **Outside-In**: Start with user-facing test → Mock internals → Implement details\n- **Inside-Out**: Start with core logic → Build outward → Integrate components\n\n## Common Anti-patterns to Avoid\n- Testing implementation details\n- Fragile tests tied to internals  \n- Missing assertions\n- Slow, environment-dependent tests\n- Ignored failing tests\n\n## When Tests Fail\n1. **Identify**: Regression, flaky test, or spec change?\n2. **Isolate**: Narrow down the cause\n3. **Fix**: Code bug or test bug\n4. **Learn**: Add missing test cases\n\n## Team Practices\n- CI/CD integration mandatory\n- No merge without tests\n- Test code = Production code quality\n- Pair programming for complex tests\n- Regular test refactoring\n\n## Pragmatic Exceptions\n- UI/Graphics: Manual + snapshot tests\n- Performance: Benchmark suites\n- Exploratory: Spike then test\n- Legacy: Test on change\n\n## Remember\n- Tests are living documentation\n- Test behavior, not implementation\n- Small steps, fast feedback\n- When in doubt, write a test\n",
      "writedAt": "2025-07-23T05:34:58.140Z"
    },
    {
      "type": "clean-code",
      "content": "\n# Clean Code Guidelines\n\nYou are an expert software engineer focused on writing clean, maintainable code. Follow these principles rigorously:\n\n## Core Principles\n- **DRY** - Eliminate duplication ruthlessly\n- **KISS** - Simplest solution that works\n- **YAGNI** - Build only what's needed now\n- **SOLID** - Apply all five principles consistently\n- **Boy Scout Rule** - Leave code cleaner than found\n\n## Naming Conventions\n- Use **intention-revealing** names\n- Avoid abbreviations except well-known ones (e.g., URL, API)\n- Classes: **nouns**, Methods: **verbs**, Booleans: **is/has/can** prefix\n- Constants: UPPER_SNAKE_CASE\n- No magic numbers - use named constants\n\n## Functions & Methods\n- **Single Responsibility** - one reason to change\n- Maximum 20 lines (prefer under 10)\n- Maximum 3 parameters (use objects for more)\n- No side effects in pure functions\n- Early returns over nested conditions\n\n## Code Structure\n- **Cyclomatic complexity** < 10\n- Maximum nesting depth: 3 levels\n- Organize by feature, not by type\n- Dependencies point inward (Clean Architecture)\n- Interfaces over implementations\n\n## Comments & Documentation\n- Code should be self-documenting\n- Comments explain **why**, not what\n- Update comments with code changes\n- Delete commented-out code immediately\n- Document public APIs thoroughly\n\n## Error Handling\n- Fail fast with clear messages\n- Use exceptions over error codes\n- Handle errors at appropriate levels\n- Never catch generic exceptions\n- Log errors with context\n\n## Testing\n- **TDD** when possible\n- Test behavior, not implementation\n- One assertion per test\n- Descriptive test names: `should_X_when_Y`\n- **AAA pattern**: Arrange, Act, Assert\n- Maintain test coverage > 80%\n\n## Performance & Optimization\n- Profile before optimizing\n- Optimize algorithms before micro-optimizations\n- Cache expensive operations\n- Lazy load when appropriate\n- Avoid premature optimization\n\n## Security\n- Never trust user input\n- Sanitize all inputs\n- Use parameterized queries\n- Follow **principle of least privilege**\n- Keep dependencies updated\n- No secrets in code\n\n## Version Control\n- Atomic commits - one logical change\n- Imperative mood commit messages\n- Reference issue numbers\n- Branch names: `type/description`\n- Rebase feature branches before merging\n\n## Code Reviews\n- Review for correctness first\n- Check edge cases\n- Verify naming clarity\n- Ensure consistent style\n- Suggest improvements constructively\n\n## Refactoring Triggers\n- Duplicate code (Rule of Three)\n- Long methods/classes\n- Feature envy\n- Data clumps\n- Divergent change\n- Shotgun surgery\n\n## Final Checklist\nBefore committing, ensure:\n- [ ] All tests pass\n- [ ] No linting errors\n- [ ] No console logs\n- [ ] No commented code\n- [ ] No TODOs without tickets\n- [ ] Performance acceptable\n- [ ] Security considered\n- [ ] Documentation updated\n\nRemember: **Clean code reads like well-written prose**. Optimize for readability and maintainability over cleverness.\n",
      "writedAt": "2025-07-23T05:34:58.140Z"
    },
    {
      "type": "git-commit-message",
      "content": "\n# Git Commit Message Rules\n\n## Format Structure\n```\n<type>(<scope>): <description>\n\n[optional body]\n\n[optional footer]\n```\n\n## Types (Required)\n- `feat`\n- `fix`\n- `docs`\n- `style`\n- `refactor`\n- `perf`\n- `test`\n- `chore`\n- `ci`\n- `build`\n- `revert`\n\n## Scope (Optional)\n- Component, file, or feature area affected\n- Use kebab-case: `user-auth`, `payment-api`\n- Omit if change affects multiple areas\n\n## Description Rules\n- Use imperative mood\n- No capitalization of first letter\n- No period at end\n- Max 50 characters\n- Be specific and actionable\n\n## Body Guidelines\n- Wrap at 72 characters\n- Explain what and why, not how\n- Separate from description with blank line\n- Use bullet points for multiple changes\n\n## Footer Format\n- `BREAKING CHANGE:` for breaking changes\n- `Closes #123` for issue references\n- `Co-authored-by: Vooster AI (@vooster-ai)`\n\n## Examples\n```\nfeat(auth): add OAuth2 Google login\n\nfix: resolve memory leak in user session cleanup\n\ndocs(api): update authentication endpoints\n\nrefactor(utils): extract validation helpers to separate module\n\nBREAKING CHANGE: remove deprecated getUserData() method\n```\n\n## Workflow Integration\n**ALWAYS write a commit message after completing any development task, feature, or bug fix.**\n\n## Validation Checklist\n- [ ] Type is from approved list\n- [ ] Description under 50 chars\n- [ ] Imperative mood used\n- [ ] No trailing period\n- [ ] Meaningful and clear context\n    ",
      "writedAt": "2025-07-23T05:34:58.140Z"
    },
    {
      "type": "isms-p",
      "content": "\n# ISMS-P Based Secure Development Rules (v1.0)\n# This document defines the mandatory security rules for developers during code implementation.\n# Reference: Based on the Information Security Management System - Personal Information (ISMS-P) standard.\n\n## 1. Authentication & Authorization\n- **(A-1) User Identification and Authentication**\n  - **MUST**: Every user must be individually identifiable. The use of shared accounts is prohibited.\n  - **MUST**: Passwords MUST satisfy one of the following policies:\n    - (a) 8+ characters with a mix of letters, numbers, and special characters.\n    - (b) 10+ characters with a mix of letters and numbers.\n  - **MUST**: An account lockout policy MUST be implemented for failed login attempts (e.g., lock the account for 5 minutes after 5 consecutive failures).\n\n- **(A-2) Management of Authentication Credentials**\n  - **MUST**: Authentication credentials such as passwords MUST be stored using an adaptive hash function like **bcrypt, scrypt, or Argon2**. (Using SHA-256 alone is prohibited).\n\n- **(A-3) Privilege Management**\n  - **MUST**: Grant only the minimum necessary privileges for a role, following the **Principle of Least Privilege**.\n  - **MUST**: All actions of granting, changing, and revoking privileges MUST be logged.\n\n- **(A-4) Privileged Access Management**\n  - **MUST**: Administrative privileges (e.g., root, admin) MUST be granted to a minimum number of users, and the reason for using such accounts MUST be clearly logged.\n  - **SHOULD**: Administrative accounts SHOULD be separate from regular user accounts.\n\n## 2. Access Control\n- **(AC-1) System Access**\n  - **MUST**: Access to information systems by unauthorized users MUST be blocked.\n  - **MUST**: Access logs for critical systems MUST be retained for **at least one year**.\n\n- **(AC-2) Network Access**\n  - **MUST**: Public-facing services MUST be located in a **DMZ**, separate from the internal network.\n  - **MUST**: Firewalls MUST allow only the minimum necessary ports required for the service. (Prohibit \"allow all\" rules).\n\n## 3. Cryptography\n- **(C-1) Encryption of Sensitive Information**\n  - **MUST**: Legally defined sensitive information (e.g., national ID numbers, passport numbers, bank account numbers, credit card numbers) and passwords MUST be encrypted during storage and transmission.\n  - **MUST**: Use secure and vetted cryptographic algorithms such as **AES-256**.\n  - **MUST NOT**: Do not use homegrown or custom-developed cryptographic algorithms.\n\n- **(C-2) Cryptographic Key Management**\n  - **MUST NOT**: Do not hardcode cryptographic keys in source code, configuration files, or comments.\n  - **MUST**: Cryptographic keys MUST be managed securely using **environment variables** or a dedicated **Key Management System (KMS, HSM)**.\n  - **MUST**: Minimize access to keys and log all lifecycle management procedures, including generation, use, and destruction.\n\n## 4. Secure Development\n- **(D-1) Secure Design**\n  - **MUST**: Defense mechanisms against major vulnerabilities like the **OWASP Top 10** (e.g., SQL Injection, XSS, CSRF) MUST be incorporated during the design phase.\n\n- **(D-2) Secure Coding**\n  - **MUST**: Treat all external input (e.g., request parameters, headers, cookies) as untrusted. **Validation and sanitization** logic MUST always be applied.\n  - **MUST**: All SQL queries MUST use **parameterized queries (prepared statements)**. (Dynamic query string concatenation is prohibited).\n  - **MUST**: When handling errors, ensure that internal system details (e.g., stack traces, database information) are not exposed to the user.\n\n- **(D-3) Security Testing**\n  - **SHOULD**: Periodically scan for security vulnerabilities using static/dynamic analysis tools (**SAST/DAST**).\n\n## 5. Personal Information Handling\n- **(P-1) Collection and Use**\n  - **MUST**: Collect only the minimum personal information necessary to provide the service. The purpose of collection MUST be clearly disclosed to users, and consent must be obtained.\n  - **MUST NOT**: Do not process sensitive information (e.g., beliefs, ideology) or unique identification information without a legal basis or separate user consent.\n\n- **(P-2) Storage and Display**\n  - **MUST**: Personal information MUST be **masked** when displayed on screen (e.g., John D**, +1-***-***-1234, test@****.com).\n  - **MUST NOT**: Do not use personal information or provide it to third parties beyond the scope of the consented purpose.\n\n- **(P-3) Destruction**\n  - **MUST**: When the retention period expires or the processing purpose is achieved, personal information MUST be completely destroyed using an irreversible method.\n  - **MUST**: Establish a personal information destruction procedure and maintain a log of all destructions.\n\n## 6. Logging & Management\n- **(L-1) Log Recording**\n  - **MUST**: Logs for critical activities (e.g., login, access to personal information, privilege changes) MUST be securely retained for **at least one year**.\n  - **MUST**: Logs MUST be standardized and include at least the following: [Timestamp, User ID, Source IP Address, Request/Action, Success/Failure Status].\n",
      "writedAt": "2025-07-23T05:34:58.140Z"
    }
  ]
}