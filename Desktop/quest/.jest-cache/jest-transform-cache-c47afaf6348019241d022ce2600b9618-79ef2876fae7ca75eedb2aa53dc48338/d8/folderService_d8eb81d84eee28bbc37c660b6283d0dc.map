{"file":"/Users/3i-a1-2021-017/Documents/quest/Desktop/quest/src/main/app/domains/folders/services/folderService.ts","mappings":"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","names":[],"sources":["/Users/3i-a1-2021-017/Documents/quest/Desktop/quest/src/main/app/domains/folders/services/folderService.ts"],"sourcesContent":["import { Folder, FolderTree, FolderCreateRequest, FolderUpdateRequest, FolderMoveRequest } from '../models/Folder';\nimport { createFolder as createFolderRepo, getFolderById as getFolderByIdRepo, updateFolder as updateFolderRepo, deleteFolder as deleteFolderRepo, listFolders, getFolderTree as getFolderTreeRepo } from '../repositories/folderRepository';\n\n// 간격법을 위한 유틸리티 함수\nfunction calculateOrderIndex(prevIndex: number | null, nextIndex: number | null): number {\n    if (prevIndex === null && nextIndex === null) return 100;\n    if (prevIndex === null) return nextIndex! - 100;\n    if (nextIndex === null) return prevIndex + 100;\n    if (nextIndex - prevIndex > 1) return Math.floor((prevIndex + nextIndex) / 2);\n    else return triggerReindex(prevIndex, nextIndex);\n}\n\nfunction triggerReindex(prevIndex: number, nextIndex: number): number {\n    // 실제로는 서버에서 전체 재간격을 수행\n    return Math.floor((prevIndex + nextIndex) / 2);\n}\n\nexport async function createFolder(data: FolderCreateRequest, createdBy: string): Promise<Folder> {\n    // 동일 부모 내 이름 중복 체크\n    const siblings = await listFolders({ parentId: data.parentId, projectId: data.projectId });\n    const duplicateName = siblings.find(f => f.name === data.name);\n    if (duplicateName) {\n        throw new Error(`폴더명 \"${data.name}\"이(가) 이미 존재합니다.`);\n    }\n\n    // orderIndex 계산\n    const orderIndex = calculateOrderIndex(\n        siblings.length > 0 ? siblings[siblings.length - 1].orderIndex : null,\n        null\n    );\n\n    // depth 계산\n    let depth = 0;\n    if (data.parentId) {\n        const parent = await getFolderByIdRepo(data.parentId);\n        if (!parent) {\n            throw new Error('부모 폴더를 찾을 수 없습니다.');\n        }\n        depth = parent.depth + 1;\n        if (depth > 10) {\n            throw new Error('폴더 깊이는 최대 10단계까지 가능합니다.');\n        }\n    }\n\n    const folderData: Omit<Folder, 'id' | 'createdAt' | 'updatedAt'> = {\n        projectId: data.projectId,\n        parentId: data.parentId,\n        name: data.name,\n        description: data.description,\n        orderIndex,\n        depth,\n        createdBy,\n        isLocked: false,\n        isArchived: false\n    };\n\n    return await createFolderRepo(folderData);\n}\n\nexport async function updateFolder(id: number, data: FolderUpdateRequest, updatedBy: string): Promise<Folder | null> {\n    const existing = await getFolderByIdRepo(id);\n    if (!existing) return null;\n\n    // 이름 변경 시 중복 체크\n    if (data.name && data.name !== existing.name) {\n        const siblings = await listFolders({ \n            parentId: existing.parentId, \n            projectId: existing.projectId \n        });\n        const duplicateName = siblings.find(f => f.id !== id && f.name === data.name);\n        if (duplicateName) {\n            throw new Error(`폴더명 \"${data.name}\"이(가) 이미 존재합니다.`);\n        }\n    }\n\n    // 부모 변경 시 순환 참조 체크\n    if (data.parentId !== undefined && data.parentId !== existing.parentId) {\n        if (data.parentId === id) {\n            throw new Error('자기 자신을 부모로 설정할 수 없습니다.');\n        }\n        \n        // 하위 폴더로 이동하는지 체크\n        const isDescendant = await checkIsDescendant(id, data.parentId);\n        if (isDescendant) {\n            throw new Error('하위 폴더로는 이동할 수 없습니다.');\n        }\n    }\n\n    return await updateFolderRepo(id, { ...data, updatedBy });\n}\n\nexport async function moveFolder(id: number, data: FolderMoveRequest, movedBy: string): Promise<Folder | null> {\n    const folder = await getFolderByIdRepo(id);\n    if (!folder) return null;\n\n    // 순환 참조 체크\n    if (data.targetParentId !== undefined) {\n        if (data.targetParentId === id) {\n            throw new Error('자기 자신을 부모로 설정할 수 없습니다.');\n        }\n        \n        const isDescendant = await checkIsDescendant(id, data.targetParentId);\n        if (isDescendant) {\n            throw new Error('하위 폴더로는 이동할 수 없습니다.');\n        }\n    }\n\n    // 드롭 타입에 따른 orderIndex 계산\n    let orderIndex: number;\n    const targetParentId = data.targetParentId !== undefined ? data.targetParentId : folder.parentId;\n    const siblings = await listFolders({ parentId: targetParentId, projectId: folder.projectId });\n    \n    switch (data.dropType) {\n        case 'before':\n            if (data.relativeToId) {\n                const relativeFolder = siblings.find(f => f.id === data.relativeToId);\n                if (relativeFolder) {\n                    orderIndex = calculateOrderIndex(null, relativeFolder.orderIndex);\n                } else {\n                    orderIndex = calculateOrderIndex(null, null);\n                }\n            } else {\n                orderIndex = calculateOrderIndex(null, null);\n            }\n            break;\n            \n        case 'after':\n            if (data.relativeToId) {\n                const relativeFolder = siblings.find(f => f.id === data.relativeToId);\n                if (relativeFolder) {\n                    orderIndex = calculateOrderIndex(relativeFolder.orderIndex, null);\n                } else {\n                    orderIndex = calculateOrderIndex(null, null);\n                }\n            } else {\n                orderIndex = calculateOrderIndex(null, null);\n            }\n            break;\n            \n        case 'into':\n        default:\n            // 자식으로 이동하는 경우 마지막 위치에 배치\n            const maxOrderIndex = siblings.length > 0 ? Math.max(...siblings.map(f => f.orderIndex)) : 0;\n            orderIndex = calculateOrderIndex(maxOrderIndex, null);\n            break;\n    }\n\n    return await updateFolderRepo(id, { \n        parentId: data.targetParentId, \n        orderIndex,\n        updatedBy: movedBy \n    });\n}\n\nexport async function moveFolderBatch(items: Array<{\n    id: string;\n    targetParentId?: number;\n    dropType: 'into' | 'before' | 'after';\n    relativeToId?: number;\n    orderIndex?: number;\n}>, movedBy: string): Promise<{\n    success: Array<{ id: string; folder: any }>;\n    failed: Array<{ id: string; error: string; reason: string }>;\n}> {\n    const results = {\n        success: [] as Array<{ id: string; folder: any }>,\n        failed: [] as Array<{ id: string; error: string; reason: string }>\n    };\n\n    // 트랜잭션으로 배치 처리\n    for (const item of items) {\n        try {\n            const folder = await moveFolder(parseInt(item.id), {\n                targetParentId: item.targetParentId,\n                dropType: item.dropType,\n                relativeToId: item.relativeToId,\n                orderIndex: item.orderIndex\n            }, movedBy);\n            \n            if (folder) {\n                results.success.push({ id: item.id, folder });\n            } else {\n                results.failed.push({ \n                    id: item.id, \n                    error: '폴더를 찾을 수 없습니다.',\n                    reason: 'FOLDER_NOT_FOUND'\n                });\n            }\n        } catch (error: any) {\n            let reason = 'UNKNOWN_ERROR';\n            if (error.message.includes('순환')) reason = 'CYCLIC_MOVE';\n            else if (error.message.includes('권한')) reason = 'PERMISSION_DENIED';\n            else if (error.message.includes('이름')) reason = 'NAME_CONFLICT';\n            else if (error.message.includes('잠금')) reason = 'LOCKED';\n            else if (error.message.includes('아카이브')) reason = 'ARCHIVED';\n            \n            results.failed.push({ \n                id: item.id, \n                error: error.message,\n                reason\n            });\n        }\n    }\n\n    return results;\n}\n\nasync function checkIsDescendant(folderId: number, targetParentId: number): Promise<boolean> {\n    const children = await listFolders({ parentId: folderId });\n    for (const child of children) {\n        if (child.id === targetParentId) return true;\n        if (await checkIsDescendant(child.id, targetParentId)) return true;\n    }\n    return false;\n}\n\nexport async function deleteFolder(id: number, mode: 'soft' | 'hard' = 'soft', deletedBy: string): Promise<boolean> {\n    console.log(`🗑️ 폴더 삭제 시도: ID ${id}, 모드: ${mode}`);\n    \n    const folder = await getFolderByIdRepo(id);\n    if (!folder) {\n        console.log(`❌ 폴더를 찾을 수 없음: ID ${id}`);\n        return false;\n    }\n\n    console.log(`✅ 폴더 찾음: ${folder.name} (ID: ${folder.id})`);\n\n    // 하위 폴더들을 재귀적으로 삭제\n    const children = await listFolders({ parentId: id });\n    console.log(`📁 하위 폴더 ${children.length}개 발견`);\n    \n    for (const child of children) {\n        console.log(`🗑️ 하위 폴더 삭제: ${child.name} (ID: ${child.id})`);\n        await deleteFolder(child.id, mode, deletedBy);\n    }\n\n    const result = await deleteFolderRepo(id, mode, deletedBy);\n    console.log(`🗑️ 폴더 삭제 결과: ${result ? '성공' : '실패'} (ID: ${id})`);\n    return result;\n}\n\nexport async function getFolderTree(projectId: number, depth?: number): Promise<FolderTree[]> {\n    return await getFolderTreeRepo(projectId, depth);\n}\n\nexport async function getFolderById(id: number): Promise<Folder | null> {\n    return await getFolderByIdRepo(id);\n}\n\nexport async function listFoldersByProject(projectId: number): Promise<Folder[]> {\n    return await listFolders({ projectId });\n} "],"version":3}